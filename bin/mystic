#!/usr/bin/env ruby

require "mystic"

MIGRATION_SELECT_SQL = "SELECT * FROM mystic_migrations"
MIGRATION_SELECT_SQL_ORDERED = MIGRATION_SELECT_SQL + " ORDER BY mig_number ASC"

MIGRATIONS_PATH = "./mystic/migrations/"
MIGRATIONS_LOCATION = MIGRATIONS_PATH + "*.rb"

FILENAME_REGEX = /^\d+\_[A-Za-z]+\.rb$/

MIG_TEMPLATE = <<-mig_template
#!/usr/bin/env ruby

require "mystic"

class <MIGRATION_CLASS_NAME> < Mystic::Migration
  def up
    
  end
  
  def down
    
  end
end
mig_template

# 1_MigrationClassName.rb

module Mystic
  def self.mig_path
    File.app_root + "/mystic/migrations/"
  end
end

include Mystic

def mig_path
  File.app_root + "/mystic/migrations/"
end

# I know this is really hacky
def migration_paths(order_matters, paths_to_reject)
  mp = mig_path()
  filenames = Dir.entries(mp).select(&FILENAME_REGEX)
  filenames.sort!{ |a,b| a.split("_").first.to_i <=> b.split("_").first.to_i } if order_matters
  filenames.map{ |filename| mp + filename }
end

case ARGV[0]
when "setup"

  Mystic.execute("CREATE TABLE IF NOT EXISTS mystic_migrations (mig_number integer, filename TEXT)")
  
when "create"
  
  case ARGV[1]
  when "migration"
    
    mg = mig_path()
    mig_name = ARGV[2].strip.capitalize
    
    Kernel.abort if mig_name.length == 0
    
    highest_mig_num = Dir.entries[mp].inject do |highest, filename|
      mig_num = filename.split("_").first.to_i
      mig_num if mig_num > highest
      highest
    end
    
    file = File.open(mp + highest_mig_num + "_" + mig_name + ".rb", "w+")
    file << MIG_TEMPLATE.sub("<MIGRATION_CLASS_NAME>",mig_name)
    
  end
  
when "migrate"
  
  migrated_filenames = []
  Mystic.execute(MIGRATION_SELECT_SQL).each { |tuple| migrated_filenames << tuple["filename"] }
  
  mp = Mystic.app_root File.app_root + "/mystic/migrations/"
  filenames = Dir.entries(mp).select(&FILENAME_REGEX)-migrated_filenames
  filenames.sort!{ |a,b| a.split("_").first.to_i <=> b.split("_").first.to_i }
  
  filenames.each do |filename|
    require mp + filename
    
    mig_number, mig_name = *filename.split("_")
    mig_name.delete!(".rb")
    
    migration = Object.const_get(mig_name).new
    migration.up
    Mystic.execute("INSERT INTO mystic_migrations (mig_number, filename) VALUES(#{mig_number},'#{filename}')")
  end
  
when "rollback"
  
  migrated_filenames = []
  Mystic.execute(MIGRATION_SELECT_SQL_ORDERED).each { |tuple| migrated_filenames << tuple["filename"] }
  
  
  
  unless migrated_filenames.empty?
    filename = migrated_filenames.last
    
    require mig_path() + filename
    migration_name = filename.split("_").last.split(".").first
  
    migration = Object.const_get(migration_name).new
    migration.down
    Mystic.execute("DELETE FROM mystic_migrations WHERE filename='#{filename}'")
  end
  
end